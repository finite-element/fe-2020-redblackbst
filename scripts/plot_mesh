#! /usr/bin/env python
from matplotlib import pyplot as plt
from fe_utils import ReferenceTriangle, UnitSquareMesh, \
    ReferenceInterval, UnitIntervalMesh, \
    LShapedMesh, \
    ReferenceRectangle, LShapedRecMesh
from argparse import ArgumentParser
import numpy as np

parser = ArgumentParser(description="""Plot the topological entities in a regular mesh.""")
parser.add_argument("mesh_type", type=int, nargs=1, choices=(0, 1, 2, 3),
                    help="Type of the mesh. 0 for interval, 1 for square, 2 for L-shaped domain"
                         "using triangular elements and 3 for L-shaped domain using rectangular elements.")
parser.add_argument("resolution", type=int, nargs=1,
                    help="The number of cells in each direction of the mesh.")


if __name__ == "__main__":
    args = parser.parse_args()
    resolution = args.resolution[0]
    mesh_type = ("UnitInterval", "UnitSquare", "LShaped", "LShapedRec")[args.mesh_type[0]]

    if mesh_type == "UnitInterval":
        mesh = UnitIntervalMesh(resolution)
    elif mesh_type == "UnitSquare":
        mesh = UnitSquareMesh(resolution, resolution)
    elif mesh_type == "LShaped":
        mesh = LShapedMesh(resolution, resolution)
    elif mesh_type == "LShapedRec":
        mesh = LShapedRecMesh(resolution, resolution)

    fig = plt.figure()
    ax = fig.add_subplot(111)

    if mesh_type == "UnitInterval":
        for e in mesh.adjacency(1, 0):
            plt.plot(mesh.vertex_coords[e, 0], 0. * mesh.vertex_coords[e, 0], 'k')
    else:
        for e in mesh.edge_vertices:
            plt.plot(mesh.vertex_coords[e, 0], mesh.vertex_coords[e, 1], 'k')

    colours = ["black", "red", "blue"]

    for i, x in enumerate(mesh.vertex_coords):
        x_ = x if mesh.dim == 2 else (x[0], 0.)
        ax.annotate('(%s, %s)' % (0, i), xy=x_, xytext=(10, 1),
                    textcoords='offset points', color=colours[0])

    for d in range(1, mesh.dim + 1):
        adj = mesh.adjacency(d, 0)
        for i, e in enumerate(adj):
            x = np.mean(mesh.vertex_coords[e, :], axis=0)
            x_ = x if mesh.dim == 2 else (x[0], 0.)
            ax.annotate('(%s, %s)' % (d, i), xy=x_, xytext=(10, 1),
                        textcoords='offset points', color=colours[d])

    if mesh_type == "UnitInterval":
        plt.plot(mesh.vertex_coords[:, 0], 0 * mesh.vertex_coords[:, 0], 'ko')

        ax.axis([-.1, 1.1, -.1, .1])
    else:
        ax.axis(np.add(ax.axis(), [-.1, .1, -.1, .1]))

    plt.show()
